const openaiService = require('./openaiService');
const fs = require('fs');
const path = require('path');

// Import specialist agents
const analyticsAgent = require('./specialists/analyticsAgent');
const persuasionAgent = require('./specialists/persuasionAgent');
const textGenerationAgent = require('./specialists/textGenerationAgent');
const htmlCssAgent = require('./specialists/htmlCssAgent');
const ethicsAgent = require('./specialists/ethicsAgent');

class MultiAgentOrchestrator {
  constructor() {
    this.specialists = {
      analytics: analyticsAgent,
      persuasion: persuasionAgent,
      textGeneration: textGenerationAgent,
      htmlCss: htmlCssAgent,
      ethics: ethicsAgent
    };
    
    // Storage for background-generated recommendations
    this.recommendationCache = new Map(); // key: requestHash, value: recommendations array
    this.cacheMaxAge = 5 * 60 * 1000; // 5 minutes
    
    this.orchestratorPersonality = {
      name: "Alex",
      role: "Project Coordinator",
      systemPrompt: `You are Alex, an experienced project coordinator running in background mode. Your role is to:

1. Generate MULTIPLE recommendations for user requests
2. Analyze different approaches and specialist inputs
3. Create comprehensive recommendation options
4. Provide diverse solutions to choose from

BACKGROUND GENERATION RULES:
- Always generate 3-5 different recommendation options
- Each recommendation should offer a different approach or specialist focus
- Include specialist analysis for each option
- Consider user profile context for personalization

AVAILABLE SPECIALISTS:
- Alex (Analytics Specialist) - for analyzing user behavior, conversion funnels, and performance optimization
- Maya (Persuasion Specialist) - for creating compelling messaging and addressing customer objections
- Sam (Content Generation Specialist) - for creating product descriptions and marketing copy
- Jordan (UI/UX Conversion Specialist) - for optimizing page layouts and checkout flows
- Dr. Riley (Ethics & Compliance Specialist) - for ensuring ethical marketing practices and compliance

PRODUCT RECOMMENDATIONS:
- When users ask for product suggestions, shopping advice, or mention wanting to buy something
- Uses user profile data (sport interests, budget, skill level, brand preferences) for personalization
- Provides tailored recommendations from available product catalog

OUTPUT FORMAT:
Generate an array of 3-5 recommendations, each with:
- approach: [ANALYTICS | PERSUASION | CONTENT | DESIGN | ETHICS | PRODUCTS | DIRECT]
- title: Brief description of the recommendation
- content: Detailed recommendation content
- score: Confidence score (1-10) for this approach`
    };

    this.selectorPersonality = {
      name: "Maya",
      role: "Recommendation Selector",
      systemPrompt: `You are Maya, an intelligent recommendation selector. Your role is to:

1. Review multiple recommendations generated by the orchestrator
2. Select the BEST recommendation based on user context and message
3. Provide the selected recommendation as your own response
4. Ensure the response feels natural and cohesive

SELECTION CRITERIA:
- Relevance to user's specific request
- Quality and completeness of the recommendation
- User profile alignment (if available)
- Confidence score from the orchestrator
- Practical applicability

RESPONSE STYLE:
- Present the selected recommendation as if you generated it yourself
- Do not mention the selection process or multiple options
- Ensure smooth, natural communication
- Maintain helpful and professional tone`
    };
  }

  // Load user profiles from personas.json
  loadUserProfiles() {
    try {
      const personasPath = path.join(__dirname, '../data/personas.json');
      const personasData = fs.readFileSync(personasPath, 'utf8');
      const personas = JSON.parse(personasData);
      return personas.userProfiles || [];
    } catch (error) {
      console.error('Error loading user profiles:', error);
      return [];
    }
  }

  // Load products from products.json
  loadProducts() {
    try {
      const productsPath = path.join(__dirname, '../data/products.json');
      const productsData = fs.readFileSync(productsPath, 'utf8');
      const products = JSON.parse(productsData);
      return products.products || [];
    } catch (error) {
      console.error('Error loading products:', error);
      return [];
    }
  }

  // Get product recommendations based on user profile
  getProductRecommendations(userProfile, limit = 3) {
    if (!userProfile) return [];
    
    const products = this.loadProducts();
    const sportInterests = this.getPropertyValues(userProfile, 'sport_interests');
    const budgetRange = this.getPropertyValues(userProfile, 'budget_range')[0] || 'moderate';
    const skillLevel = this.getPropertyValues(userProfile, 'skill_level')[0] || 'intermediate';
    const preferredBrands = this.getPropertyValues(userProfile, 'preferred_brands');
    
    // Filter products by sport interests
    let relevantProducts = products.filter(product => 
      sportInterests.includes(product.category)
    );
    
    // If no sport-specific products, include tennis as fallback
    if (relevantProducts.length === 0) {
      relevantProducts = products.filter(product => 
        product.category === 'tennis' || sportInterests.includes(product.category)
      );
    }
    
    // Score products based on profile match
    const scoredProducts = relevantProducts.map(product => {
      let score = 0;
      
      // Brand preference bonus
      if (preferredBrands.includes(product.brand)) {
        score += 30;
      }
      
      // Budget alignment
      const discountedPrice = product.price * (1 - product.discount / 100);
      if (budgetRange === 'budget' && discountedPrice <= 200) score += 25;
      else if (budgetRange === 'moderate' && discountedPrice >= 100 && discountedPrice <= 500) score += 25;
      else if (budgetRange === 'premium' && discountedPrice >= 200 && discountedPrice <= 800) score += 25;
      else if (budgetRange === 'luxury' && discountedPrice >= 400) score += 25;
      
      // Skill level consideration (higher priced items for advanced/professional)
      if (skillLevel === 'professional' && discountedPrice >= 500) score += 20;
      else if (skillLevel === 'advanced' && discountedPrice >= 200) score += 15;
      else if (skillLevel === 'intermediate' && discountedPrice >= 100 && discountedPrice <= 600) score += 15;
      else if (skillLevel === 'recreational' && discountedPrice <= 400) score += 15;
      
      // Stock availability
      if (product.stock > 10) score += 10;
      else if (product.stock > 0) score += 5;
      
      // Discount bonus
      if (product.discount > 15) score += 10;
      else if (product.discount > 0) score += 5;
      
      return { ...product, score };
    });
    
    // Sort by score and return top recommendations
    return scoredProducts
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  }

  // Helper method to get property values from user profile
  getPropertyValues(userProfile, propertyId) {
    if (!userProfile.properties) return [];
    const property = userProfile.properties.find(prop => prop.id === propertyId);
    return property ? property.values : [];
  }

  // Format product recommendations for display
  formatProductRecommendations(recommendations, userProfile) {
    if (recommendations.length === 0) {
      return '\nNo specific product recommendations available based on your profile.';
    }
    
    const userName = this.getPropertyValues(userProfile, 'name')[0] || 'there';
    const sportInterests = this.getPropertyValues(userProfile, 'sport_interests');
    
    let output = `\n--- PERSONALIZED PRODUCT RECOMMENDATIONS FOR ${userName.toUpperCase()} ---\n`;
    output += `Based on your interests in: ${sportInterests.join(', ')}\n\n`;
    
    recommendations.forEach((product, index) => {
      const discountedPrice = product.price * (1 - product.discount / 100);
      const savings = product.price - discountedPrice;
      
      output += `${index + 1}. ${product.name} by ${product.brand}\n`;
      output += `   ${product.description}\n`;
      output += `   Price: $${discountedPrice.toFixed(2)}`;
      if (product.discount > 0) {
        output += ` (was $${product.price}, save $${savings.toFixed(2)})`;
      }
      output += `\n   Stock: ${product.stock} available\n`;
      output += `   Match Score: ${product.score}/100\n\n`;
    });
    
    return output;
  }

  // Get user profile by ID
  getUserProfile(profileId) {
    if (!profileId) return null;
    
    const userProfiles = this.loadUserProfiles();
    return userProfiles.find(profile => profile.id === profileId) || null;
  }

  // Format user profile for agents
  formatUserProfileForAgents(userProfile) {
    if (!userProfile) return '';
    
    let profileInfo = '\n--- USER PROFILE CONTEXT ---\n';
    profileInfo += `User ID: ${userProfile.id}\n`;
    profileInfo += `Permission Level: ${userProfile.permissions?.level || 'Unknown'}\n`;
    
    if (userProfile.properties) {
      profileInfo += 'User Properties:\n';
      userProfile.properties.forEach(prop => {
        profileInfo += `- ${prop.id}: ${prop.values.join(', ')}\n`;
      });
    }
    
    if (userProfile.segments && userProfile.segments.length > 0) {
      profileInfo += `User Segments: ${userProfile.segments.map(s => s.id).join(', ')}\n`;
    }
    
    if (userProfile.consentedObjectives && userProfile.consentedObjectives.length > 0) {
      profileInfo += `Consented Features: ${userProfile.consentedObjectives.join(', ')}\n`;
    }
    
    if (userProfile.refusedObjectives && userProfile.refusedObjectives.length > 0) {
      profileInfo += `Refused Features: ${userProfile.refusedObjectives.join(', ')}\n`;
    }
    
    profileInfo += '--- END USER PROFILE ---\n\n';
    return profileInfo;
  }

  async processUserMessage(request) {
    try {
      // Handle both string and JSON request formats
      let message, profileId;
      
      if (typeof request === 'string') {
        message = request;
        profileId = null;
      } else if (typeof request === 'object' && request.message) {
        message = request.message;
        profileId = request.profileId || null;
      } else {
        throw new Error('Invalid request format. Expected string or {message, profileId}');
      }

      // Get user profile if profileId is provided
      const userProfile = this.getUserProfile(profileId);

      // Clean expired cache entries
      this.cleanExpiredCache();

      // Generate request hash for caching
      const requestHash = this.generateRequestHash(message, userProfile);

      // Check cache first
      let recommendations;
      const cached = this.recommendationCache.get(requestHash);
      
      if (cached && (Date.now() - cached.timestamp < this.cacheMaxAge)) {
        recommendations = cached.recommendations;
        console.log('Using cached recommendations for request:', requestHash);
      } else {
        // Generate new recommendations in background
        console.log('Generating new recommendations for request:', requestHash);
        recommendations = await this.generateBackgroundRecommendations(message, userProfile);
        
        // Store in cache
        this.recommendationCache.set(requestHash, {
          recommendations: recommendations,
          timestamp: Date.now()
        });
      }

      // Use selector agent to pick best recommendation
      const selectedResponse = await this.selectBestRecommendation(recommendations, message, userProfile);

      return {
        response: selectedResponse,
        currentAgent: 'Maya (Recommendation Selector)',
        timestamp: new Date().toISOString(),
        userProfile: userProfile ? { id: userProfile.id, segments: userProfile.segments } : null,
        generatedRecommendations: recommendations.length,
        cached: !!cached
      };

    } catch (error) {
      console.error('Multi-agent processing error:', error);
      throw new Error(`Multi-agent processing failed: ${error.message}`);
    }
  }

  // New methods for direct specialist consultation
  async consultSpecialistDirectly(specialistType, method, userMessage, ...args) {
    try {
      const specialist = this.specialists[specialistType];
      if (!specialist) {
        throw new Error(`Unknown specialist type: ${specialistType}`);
      }
      
      if (typeof specialist[method] !== 'function') {
        throw new Error(`Unknown method ${method} for specialist ${specialistType}`);
      }
      
      return await specialist[method](userMessage, ...args);
    } catch (error) {
      console.error(`Error consulting ${specialistType} specialist:`, error);
      throw error;
    }
  }

  async callOpenAI(prompt, agentName = 'System') {
    return await openaiService.createSimpleCompletion(prompt, {
      model: openaiService.getAvailableModels().GPT_4O,
      maxTokens: openaiService.getTokenLimits().EXTENDED,
      temperature: 0.7
    });
  }

  // Utility methods for getting specialist personalities
  getSpecialistPersonalities() {
    const personalities = {};
    
    // Get personalities from available specialists
    Object.entries(this.specialists).forEach(([key, specialist]) => {
      if (specialist && typeof specialist.getPersonality === 'function') {
        personalities[key] = specialist.getPersonality();
      }
    });
    
    return personalities;
  }

  listAvailableSpecialists() {
    const personalities = this.getSpecialistPersonalities();
    return Object.entries(personalities).map(([key, personality]) => ({
      id: key,
      name: personality.name,
      role: personality.role
    }));
  }

  // Utility methods for accessing stored recommendations
  getCachedRecommendations(message, userProfile) {
    const requestHash = this.generateRequestHash(message, userProfile);
    const cached = this.recommendationCache.get(requestHash);
    return cached ? cached.recommendations : null;
  }

  getCacheStatistics() {
    this.cleanExpiredCache();
    return {
      totalCachedRequests: this.recommendationCache.size,
      cacheMaxAge: this.cacheMaxAge,
      oldestEntry: this.recommendationCache.size > 0 ? 
        Math.min(...Array.from(this.recommendationCache.values()).map(v => v.timestamp)) : null,
      newestEntry: this.recommendationCache.size > 0 ? 
        Math.max(...Array.from(this.recommendationCache.values()).map(v => v.timestamp)) : null
    };
  }

  clearRecommendationCache() {
    this.recommendationCache.clear();
    return { message: 'Recommendation cache cleared successfully' };
  }

  // Generate hash for caching recommendations
  generateRequestHash(message, userProfile) {
    const profileId = userProfile?.id || 'anonymous';
    const content = `${message}_${profileId}`;
    return require('crypto').createHash('md5').update(content).digest('hex');
  }

  // Clean expired cache entries
  cleanExpiredCache() {
    const now = Date.now();
    for (const [key, value] of this.recommendationCache.entries()) {
      if (now - value.timestamp > this.cacheMaxAge) {
        this.recommendationCache.delete(key);
      }
    }
  }

  // Background orchestrator - generates multiple recommendations
  async generateBackgroundRecommendations(message, userProfile) {
    const userProfileContext = this.formatUserProfileForAgents(userProfile);
    
    const prompt = {
      system: this.orchestratorPersonality.systemPrompt,
      user: `${userProfileContext}USER MESSAGE:
${message}

Generate 3-5 different recommendation approaches for this user request. Each recommendation should offer a different perspective or specialist focus.

Return your response as a valid JSON array with this structure:
[
  {
    "approach": "ANALYTICS",
    "title": "Brief title for this approach",
    "content": "Detailed recommendation content",
    "score": 8
  },
  {
    "approach": "PERSUASION", 
    "title": "Brief title for this approach",
    "content": "Detailed recommendation content", 
    "score": 7
  }
]

Ensure each recommendation is complete and actionable.`
    };

    try {
      const response = await this.callOpenAI(prompt, 'Background Orchestrator');
      
      // Parse the JSON response
      const cleanResponse = response.replace(/```json|```/g, '').trim();
      const recommendations = JSON.parse(cleanResponse);
      
      // Validate the structure
      if (!Array.isArray(recommendations)) {
        throw new Error('Response is not an array');
      }
      
      // Enrich recommendations with specialist input
      for (let rec of recommendations) {
        if (rec.approach !== 'DIRECT' && rec.approach !== 'PRODUCTS') {
          rec.content = await this.enrichWithSpecialist(rec.approach, message, userProfile, rec.content);
        } else if (rec.approach === 'PRODUCTS') {
          const productRecs = this.getProductRecommendations(userProfile);
          const formattedProducts = this.formatProductRecommendations(productRecs, userProfile);
          rec.content += formattedProducts;
        }
      }
      
      return recommendations;
    } catch (error) {
      console.error('Error generating background recommendations:', error);
      // Fallback to simple recommendations
      return await this.generateFallbackRecommendations(message, userProfile);
    }
  }

  // Enrich recommendation with specialist input
  async enrichWithSpecialist(approach, message, userProfile, baseContent) {
    const userProfileContext = this.formatUserProfileForAgents(userProfile);
    const fullContext = userProfileContext + `USER MESSAGE: ${message}`;
    
    try {
      let specialistResponse;
      switch (approach) {
        case 'ANALYTICS':
          specialistResponse = await this.specialists.analytics.analyzeConversion(fullContext);
          return baseContent + '\n\n' + specialistResponse.analysis;
        case 'PERSUASION':
          specialistResponse = await this.specialists.persuasion.createPersuasiveContent(fullContext);
          return baseContent + '\n\n' + specialistResponse.content;
        case 'CONTENT':
          specialistResponse = await this.specialists.textGeneration.generateProductContent(fullContext);
          return baseContent + '\n\n' + specialistResponse.content;
        case 'DESIGN':
          specialistResponse = await this.specialists.htmlCss.optimizePageLayout(fullContext, 'product_page');
          return baseContent + '\n\n' + specialistResponse.optimization;
        case 'ETHICS':
          specialistResponse = await this.specialists.ethics.reviewMarketingEthics(fullContext);
          return baseContent + '\n\n' + specialistResponse.review;
        default:
          return baseContent;
      }
    } catch (error) {
      console.error(`Error enriching with ${approach} specialist:`, error);
      return baseContent;
    }
  }

  // Fallback recommendations if JSON parsing fails
  async generateFallbackRecommendations(message, userProfile) {
    const hasProfile = userProfile && userProfile.id;
    
    const recommendations = [
      {
        approach: 'DIRECT',
        title: 'Direct Response',
        content: 'I understand your request. Let me provide you with a comprehensive response based on best practices.',
        score: 7
      }
    ];

    if (hasProfile) {
      recommendations.push({
        approach: 'PRODUCTS',
        title: 'Product Recommendations',
        content: 'Based on your profile, here are some personalized recommendations:',
        score: 8
      });
    }

    return recommendations;
  }

  // Selector agent - picks best recommendation
  async selectBestRecommendation(recommendations, message, userProfile) {
    const userProfileContext = this.formatUserProfileForAgents(userProfile);
    
    const recommendationsText = recommendations.map((rec, index) => 
      `Option ${index + 1} (${rec.approach}, Score: ${rec.score}):
Title: ${rec.title}
Content: ${rec.content.substring(0, 200)}...`
    ).join('\n\n');
    
    const prompt = {
      system: this.selectorPersonality.systemPrompt,
      user: `${userProfileContext}USER MESSAGE:
${message}

AVAILABLE RECOMMENDATIONS:
${recommendationsText}

Select the BEST recommendation for this user and message. Return ONLY the content of your selected recommendation, presented as your own natural response. Do not mention the selection process or multiple options.`
    };

    try {
      const selectedResponse = await this.callOpenAI(prompt, 'Recommendation Selector');
      return selectedResponse;
    } catch (error) {
      console.error('Error in recommendation selection:', error);
      // Fallback to highest scored recommendation
      const bestRec = recommendations.sort((a, b) => b.score - a.score)[0];
      return bestRec?.content || 'I apologize, but I encountered an issue processing your request. Please try again.';
    }
  }
}

module.exports = new MultiAgentOrchestrator(); 